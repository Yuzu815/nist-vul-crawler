{
  "input": "img_t table_ptr; /*struct containing img data, 10kB each*/int num_imgs;...num_imgs = get_num_imgs();table_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);...",
  "output": "This program snippet has a vulnerability.The following image processing code allocates a table for images.This code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119)."
}
{
  "input": "nresp = packet_get_int();if (nresp > 0) {response = xmalloc(nresp*sizeof(char*));for (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);}",
  "output": "This program snippet has a vulnerability.The following code excerpt from OpenSSH 3.3 demonstrates a classic case of integer overflow:If nresp has the value 1073741824 and sizeof(char*) has its typical value of 4, then the result of the operation nresp*sizeof(char*) overflows, and the argument to xmalloc() will be 0. Most malloc() implementations will happily allocate a 0-byte buffer, causing the subsequent loop iterations to overflow the heap buffer response."
}
{
  "input": "short int bytesRec = 0;char buf[SOMEBIGNUM];\nwhile(bytesRec < MAXGET) {bytesRec += getFromInput(buf+bytesRec);}",
  "output": "This program snippet has a vulnerability.Integer overflows can be complicated and difficult to detect. The following example is an attempt to show how an integer overflow may lead to undefined looping behavior:In the above case, it is entirely possible that bytesRec may overflow, continuously creating a lower number than MAXGET and also overwriting the first MAXGET-1 bytes of buf."
}
{
  "input": "#define JAN 1#define FEB 2#define MAR 3\nshort getMonthlySales(int month) {...}\nfloat calculateRevenueForQuarter(short quarterSold) {...}\nint determineFirstQuarterRevenue() {\n\n\n// Variable for sales revenue for the quarter\nfloat quarterRevenue = 0.0f;\nshort JanSold = getMonthlySales(JAN); /* Get sales in January */short FebSold = getMonthlySales(FEB); /* Get sales in February */short MarSold = getMonthlySales(MAR); /* Get sales in March */\n\n// Calculate quarterly total\nshort quarterSold = JanSold + FebSold + MarSold;\n\n// Calculate the total revenue for the quarter\nquarterRevenue = calculateRevenueForQuarter(quarterSold);\nsaveFirstQuarterRevenue(quarterRevenue);\nreturn 0;\n}",
  "output": "This program snippet has a vulnerability.In this example the method determineFirstQuarterRevenue is used to determine the first quarter revenue for an accounting/business application. The method retrieves the monthly sales totals for the first three months of the year, calculates the first quarter sales totals from the monthly sales totals, calculates the first quarter revenue based on the first quarter sales, and finally saves the first quarter revenue results to the database.However, in this example the primitive type short int is used for both the monthly and the quarterly sales variables. In C the short int primitive type has a maximum value of 32768. This creates a potential integer overflow if the value for the three monthly sales adds up to more than the maximum value for the short int primitive type. An integer overflow can lead to data corruption, unexpected behavior, infinite loops and system crashes. To correct the situation the appropriate primitive type should be used, as in the example below, and/or provide some validation mechanism to ensure that the maximum value for the primitive type is not exceeded.Note that an integer overflow could also occur if the quarterSold variable has a primitive type long but the method calculateRevenueForQuarter has a parameter of type short."
}
