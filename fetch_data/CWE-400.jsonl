{
  "input": "class Worker implements Executor {\n...public void execute(Runnable r) {\n\ntry {...}catch (InterruptedException ie) {\n\n\n// postpone response\nThread.currentThread().interrupt();\n}\n}\npublic Worker(Channel ch, int nworkers) {...}\nprotected void activate() {\n\nRunnable loop = new Runnable() {\n\npublic void run() {\n\ntry {for (;;) {Runnable r = ...;r.run();}}catch (InterruptedException ie) {...}\n}\n};new Thread(loop).start();\n}\n}",
  "output": "This program snippet has a vulnerability.The following example demonstrates the weakness.There are no limits to runnables. Potentially an attacker could cause resource problems very quickly."
}
{
  "input": "sock=socket(AF_INET, SOCK_STREAM, 0);while (1) {newsock=accept(sock, ...);printf(\"A connection has been accepted\\n\");pid = fork();}",
  "output": "This program snippet has a vulnerability.This code allocates a socket and forks each time it receives a new connection.The program does not track how many connections have been made, and it does not limit the number of connections. Because forking is a relatively expensive operation, an attacker would be able to cause the system to run out of CPU, processes, or memory by making a large number of connections. Alternatively, an attacker could consume all available connections, preventing others from accessing the system remotely."
}
{
  "input": "int writeDataFromSocketToFile(char *host, int port){\n\nchar filename[FILENAME_SIZE];char buffer[BUFFER_SIZE];int socket = openSocketConnection(host, port);\nif (socket < 0) {printf(\"Unable to open socket connection\");return(FAIL);}if (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\nif (openFileToWrite(filename) > 0) {\nwhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){if (!(writeToFile(buffer) > 0))break;\n}\n}closeFile();\n}closeSocket(socket);\n}",
  "output": "This program snippet has a vulnerability.In the following example a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method openSocketConnection establishes a server socket to accept requests from a client. When a client establishes a connection to this service the getNextMessage method is first used to retrieve from the socket the name of the file to store the data, the openFileToWrite method will validate the filename and open a file to write to on the local file system. The getNextMessage is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket.This example creates a situation where data can be dumped to a file on the local file system without any limits on the size of the file. This could potentially exhaust file or disk resources and/or limit other clients' ability to access the service."
}
{
  "input": "/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */\nint processMessage(char **message){\nchar *body;\nint length = getMessageLength(message[0]);\nif (length > 0) {body = &message[1][0];processMessageBody(body);return(SUCCESS);}else {printf(\"Unable to process message; invalid message length\");return(FAIL);}\n}",
  "output": "This program snippet has a vulnerability.In the following example, the processMessage method receives a two dimensional character array containing the message to be processed. The two-dimensional character array contains the length of the message in the first character array and the message body in the second character array. The getMessageLength method retrieves the integer value of the length from the first character array. After validating that the message length is greater than zero, the body character array pointer points to the start of the second character array of the two-dimensional character array and memory is allocated for the new body character array.This example creates a situation where the length of the body character array can be very large and will consume excessive memory, exhausting system resources. This can be avoided by restricting the length of the second character array with a maximum length checkAlso, consider changing the type from 'int' to 'unsigned int', so that you are always guaranteed that the number is positive. This might not be possible if the protocol specifically requires allowing negative values, or if you cannot control the return value from getMessageLength(), but it could simplify the check to ensure the input is positive, and eliminate other errors such as signed-to-unsigned conversion errors (CWE-195) that may occur elsewhere in the code."
}
{
  "input": "public void acceptConnections() {\n\ntry {ServerSocket serverSocket = new ServerSocket(SERVER_PORT);int counter = 0;boolean hasConnections = true;while (hasConnections) {Socket client = serverSocket.accept();Thread t = new Thread(new ClientSocketThread(client));t.setName(client.getInetAddress().getHostName() + \":\" + counter++);t.start();}serverSocket.close();\n\n} catch (IOException ex) {...}\n}",
  "output": "This program snippet has a vulnerability.In the following example, a server object creates a server socket and accepts client connections to the socket. For every client connection to the socket a separate thread object is generated using the ClientSocketThread class that handles request made by the client through the socket.In this example there is no limit to the number of client connections and client threads that are created. Allowing an unlimited number of client connections and threads could potentially overwhelm the system and system resources.The server should limit the number of client connections and the client threads that are created. This can be easily done by creating a thread pool object that limits the number of threads that are generated."
}
