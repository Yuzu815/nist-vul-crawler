{
  "input": "char buf[10], cp_buf[10];fgets(buf, 10, stdin);strcpy(cp_buf, buf);",
  "output": "This program snippet has a vulnerability.Consider the following code segment:The programmer expects that when fgets() returns, buf will contain a null-terminated string of length 9 or less. But if an I/O error occurs, fgets() will not null-terminate buf. Furthermore, if the end of the file is reached before any characters are read, fgets() returns without writing anything to buf. In both of these situations, fgets() signals that something unusual has happened by returning NULL, but in this code, the warning will not be noticed. The lack of a null terminator in buf can result in a buffer overflow in the subsequent call to strcpy()."
}
{
  "input": "int returnChunkSize(void *) {\n\n\n/* if chunk info is valid, return the size of usable memory,\n\n\n* else, return -1 to indicate an error\n\n\n*/\n...\n}int main() {...memcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));...}",
  "output": "This program snippet has a vulnerability.In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
}
{
  "input": "buf = (char*) malloc(req_size);strncpy(buf, xfer, req_size);",
  "output": "This program snippet has a vulnerability.The following code does not check to see if memory allocation succeeded before attempting to use the pointer returned by malloc().The traditional defense of this coding error is: \"If my program runs out of memory, it will fail. It doesn't matter whether I handle the error or allow the program to die with a segmentation fault when it tries to dereference the null pointer.\" This argument ignores three important considerations:\n\n\nDepending upon the type and size of the application, it may be possible to free memory that is being used elsewhere so that execution can continue.\n\n\nIt is impossible for the program to perform a graceful exit if required. If the program is performing an atomic operation, it can leave the system in an inconsistent state.\n\n\nThe programmer has lost the opportunity to record diagnostic information. Did the call to malloc() fail because req_size was too large or because there were too many requests being handled at the same time? Or was it caused by a memory leak that has built up over time? Without handling the error, there is no way to know."
}
{
  "input": "FileInputStream fis;byte[] byteArray = new byte[1024];for (Iterator i=users.iterator(); i.hasNext();) {\nString userName = (String) i.next();String pFileName = PFILE_ROOT + \"/\" + userName;FileInputStream fis = new FileInputStream(pFileName);fis.read(byteArray); // the file is always 1k bytesfis.close();processPFile(userName, byteArray);",
  "output": "This program snippet has a vulnerability.The following examples read a file into a byte array.The code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always 1 kilobyte in size and therefore ignores the return value from Read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and treat it as though it belongs to the attacker."
}
{
  "input": "String itemName = request.getParameter(ITEM_NAME);if (itemName.compareTo(IMPORTANT_ITEM) == 0) {...}...",
  "output": "This program snippet has a vulnerability.The following code does not check to see if the string returned by getParameter() is null before calling the member function compareTo(), potentially causing a NULL dereference.The following code does not check to see if the string returned by the Item property is null before calling the member function Equals(), potentially causing a NULL dereference.The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
}
{
  "input": "String itemName = request.Item(ITEM_NAME);if (itemName.Equals(IMPORTANT_ITEM)) {...}...",
  "output": "This program snippet has a vulnerability.The following code does not check to see if the string returned by getParameter() is null before calling the member function compareTo(), potentially causing a NULL dereference.The following code does not check to see if the string returned by the Item property is null before calling the member function Equals(), potentially causing a NULL dereference.The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
}
{
  "input": "System.clearProperty(\"os.name\");...String os = System.getProperty(\"os.name\");if (os.equalsIgnoreCase(\"Windows 95\")) System.out.println(\"Not supported\");",
  "output": "This program snippet has a vulnerability.The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined.The traditional defense of this coding error is: \"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or allow the program to die dereferencing a null value.\" But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
}
{
  "input": "void host_lookup(char *user_supplied_addr){\nstruct hostent *hp;in_addr_t *addr;char hostname[64];in_addr_t inet_addr(const char *cp);\n\n/*routine that ensures user_supplied_addr is in the right format for conversion */\n\nvalidate_addr_form(user_supplied_addr);addr = inet_addr(user_supplied_addr);hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);strcpy(hostname, hp->h_name);\n}",
  "output": "This program snippet has a vulnerability.This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy(). Note that this code is also vulnerable to a buffer overflow (CWE-119)."
}
{
  "input": "void f(pthread_mutex_t *mutex) {\npthread_mutex_lock(mutex);\n\n/* access shared resource */\n\n\npthread_mutex_unlock(mutex);\n}",
  "output": "This program snippet has a vulnerability.The following function attempts to acquire a lock in order to perform operations on a shared resource.However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior.In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
}
