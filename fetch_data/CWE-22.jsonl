{
  "input": "String filename = System.getProperty(\"com.domain.application.dictionaryFile\");File dictionaryFile = new File(filename);",
  "output": "This program snippet has a vulnerability.In the example below, the path to a dictionary file is read from a system property and used to initialize a File object.However, the path is not validated or modified to prevent it from containing relative or absolute path sequences before creating the File object. This allows anyone who can control the system property to determine what file is used. Ideally, the path should be resolved relative to some kind of application or user home directory."
}
{
  "input": "String path = getInputPath();if (path.startsWith(\"/safe_dir/\")){File f = new File(path);f.delete()}",
  "output": "This program snippet has a vulnerability.The following code attempts to validate a given input path by checking it against an allowlist and once validated delete the given file. In this specific case, the path is considered valid if it starts with the string \"/safe_dir/\".An attacker could provide an input such as this:The software assumes that the path is valid because it starts with the \"/safe_path/\" sequence, but the \"../\" sequence will cause the program to delete the important.dat file in the parent directory"
}
{
  "input": "public class FileUploadServlet extends HttpServlet {\n\n...\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\nresponse.setContentType(\"text/html\");PrintWriter out = response.getWriter();String contentType = request.getContentType();\n// the starting position of the boundary headerint ind = contentType.indexOf(\"boundary=\");String boundary = contentType.substring(ind+9);\nString pLine = new String();String uploadLocation = new String(UPLOAD_DIRECTORY_STRING); //Constant value\n// verify that content type is multipart form dataif (contentType != null && contentType.indexOf(\"multipart/form-data\") != -1) {\n\n// extract the filename from the Http headerBufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream()));...pLine = br.readLine();String filename = pLine.substring(pLine.lastIndexOf(\"\\\\\"), pLine.lastIndexOf(\"\\\"\"));...\n// output the file to the local upload directorytry {\nBufferedWriter bw = new BufferedWriter(new FileWriter(uploadLocation+filename, true));for (String line; (line=br.readLine())!=null; ) {if (line.indexOf(boundary) == -1) {bw.write(line);bw.newLine();bw.flush();}} //end of for loopbw.close();\n\n\n} catch (IOException ex) {...}// output successful upload response HTML page\n}// output unsuccessful upload response HTML pageelse{...}\n}...\n\n}",
  "output": "This program snippet has a vulnerability.The following code demonstrates the unrestricted upload of a file with a Java servlet and a path traversal vulnerability. The action attribute of an HTML form is sending the upload file request to the Java servlet.When submitted the Java servlet's doPost method will receive the request, extract the name of the file from the Http request header, read the file contents from the request and output the file to the local upload directory.This code does not perform a check on the type of the file being uploaded (CWE-434). This could allow an attacker to upload any executable file or other file with malicious code. Additionally, the creation of the BufferedWriter object is subject to relative path traversal (CWE-23). Since the code does not check the filename that is provided in the header, an attacker can use \"../\" sequences to write to files outside of the intended directory. Depending on the executing environment, the attacker may be able to specify arbitrary files to write to, leading to a wide variety of consequences, from code execution, XSS (CWE-79), or system crash."
}
{
  "input": "import os\n                  import sys\n                  def main():\n\n                     filename = sys.argv[1]\n                     path = os.path.join(os.getcwd(), filename)\n                     try:\n\n                        with open(path, 'r') as f:\n\n                           file_data = f.read()\n\n\n                     except FileNotFoundError as e:\n\n                        print(\"Error - file not found\")\n\n\n                  main()",
  "output": "This program snippet has a vulnerability.This script intends to read a user-supplied file from the current directory. The user inputs the relative path to the file and the script uses Python's os.path.join() function to combine the path to the current working directory with the provided path to the specified file. This results in an absolute path to the desired file. If the file does not exist when the script attempts to read it, an error is printed to the user.However, if the user supplies an absolute path, the os.path.join() function will discard the path to the current working directory and use only the absolute path provided. For example, if the current working directory is /home/user/documents, but the user inputs /etc/passwd, os.path.join() will use only /etc/passwd, as it is considered an absolute path. In the above scenario, this would cause the script to access and read the /etc/passwd file.The constructed path string uses os.sep to add the appropriate separation character for the given operating system (e.g. '\\' or '/') and the call to os.path.normpath() removes any additional slashes that may have been entered - this may occur particularly when using a Windows path. By putting the pieces of the path string together in this fashion, the script avoids a call to os.path.join() and any potential issues that might arise if an absolute path is entered. With this version of the script, if the current working directory is /home/user/documents, and the user inputs /etc/passwd, the resulting path will be /home/user/documents/etc/passwd. The user is therefore contained within the current working directory as intended."
}
