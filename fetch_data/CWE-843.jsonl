{
  "input": "#define NAME_TYPE 1#define ID_TYPE 2\nstruct MessageBuffer{int msgType;union {char *name;int nameID;};};\n\nint main (int argc, char **argv) {\nstruct MessageBuffer buf;char *defaultMessage = \"Hello World\";\nbuf.msgType = NAME_TYPE;buf.name = defaultMessage;printf(\"Pointer of buf.name is %p\\n\", buf.name);\n/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */\n\nbuf.nameID = (int)(defaultMessage + 1);printf(\"Pointer of buf.name is now %p\\n\", buf.name);if (buf.msgType == NAME_TYPE) {printf(\"Message: %s\\n\", buf.name);}else {printf(\"Message: Use ID %d\\n\", buf.nameID);}\n}",
  "output": "This program snippet has a vulnerability.The following code uses a union to support the representation of different types of messages. It formats messages differently, depending on their type.The code intends to process the message as a NAME_TYPE, and sets the default message to \"Hello World.\" However, since both buf.name and buf.nameID are part of the same union, they can act as aliases for the same memory location, depending on memory layout after compilation.As a result, modification of buf.nameID - an int - can effectively modify the pointer that is stored in buf.name - a string.Execution of the program might generate output such as:\n\nPointer of name is 10830\nPointer of name is now 10831\nMessage: ello World\n\nNotice how the pointer for buf.name was changed, even though buf.name was not explicitly modified.In this case, the first \"H\" character of the message is omitted. However, if an attacker is able to fully control the value of buf.nameID, then buf.name could contain an arbitrary pointer, leading to out-of-bounds reads or writes."
}
